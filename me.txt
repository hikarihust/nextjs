                                        Giới thiệu NextJs
            
Tìm hiểu cấu trúc ứng dụng NextJs đầu tiên
    Lệnh tạo project: 
        npx create-next-app first-project-nextjs 
    Cài đặt yarn: 
        npm install -g yarn
    Một số lệnh
        npm run dev
            Starts the development server.
        npm run build
            Builds the app for production.
        npm start
            Runs the built app in production mode.
    npm run dev
    Cấu trúc thư mục 
    Mặc định trang chủ là:  pages/index.js 
    pages/api/ Là nơi có thể code backend(nodejs)
        http://localhost:3000/api/hello
        http://localhost:3000/user

Deploy ứng dụng NextJs đầu tiên
    Create new app: first-nextjs
    Tab Deploy:
        GitHub
        Connect to GitHub
    Connect to GitHub
        repo-name: first-nextjs
    Choose a branch to deploy:
        master 
        -> Deploy branch
    View 
    Application error
        Edit package.json: "start": "next start -p $PORT"
    https://first-nextjs.herokuapp.com/

=============================================================================================
                            Tìm hiểu NextJs cơ bản

Cài đặt và tích hợp Typescript với NextJs và React 
    npm install --save-dev typescript @types/react @types/node
    yarn dev
    Khi sử dụng typescript thì các file liên quan(index.js...) thì đều có thể sử dụng song song 
        cả javascript và typescript tuy nhiên khi làm dự án thực tế thì thường đổi lại đuôi của các 
        file đó:
        Dùng typescript: js -> ts
        File nào dùng cú pháp của jsx(các file liên quan đến Component): js -> tsx
            index.tsx
            user.tsx
        pages/api/hello.ts 
Tìm hiểu về khái niệm Pages trong NextJs
Tìm hiểu Dynamic Route
    admin/user/[id]
Tìm hiểu Routing Basic
    Lấy được tham số ở trên đường dẫn 
Tìm hiểu Static File Serving và cách cài đặt
Custom lại Webpack và cách dùng File loader 
    Custom Webpack Config
    https://webpack.js.org/concepts/#loaders
    npm install url-loader --save-dev
    zeit config plugins
        https://github.com/vercel/next-plugins
        next-images
        npm install --save next-images
    npm remove url-loader
Custom App Component và CSS Module Support
    pageProps = {
       users: [],
       posts: [],
       isLogin: true 
    }
    {...pageProps}
        users = pageProps.users
        posts = pageProps.posts
        isLogin = pageProps.isLogin
    Sass Support
        npm install --save @zeit/next-sass node-sass
        https://github.com/vercel/next-plugins
    module.exports = withImages(
        withSass()
    )
Custom App Component và Typescript
    Khai báo Custom App theo kiểu Typescript -> Khai báo thêm kiểu cho App 
    App: Có thể khai báo theo kiểu Class và function Component

=============================================================================================
                            Life Cycle, React Hooks và ứng dụng
            
Ôn tập Life Cycle cơ bản trong Class Component
    state: Là data của Component, do chính nó quản lý
    props: Là data của 2 nơi khác truyền vào cho nó, nó chỉ nhận thôi, không thể thay đổi
Cách sử dụng State Hooks và so sánh
Tìm hiểu về useEffect trong Hooks
    Use Effect
        Trong LifeCycle thường là nơi gọi ra các service ở bên ngoài như là call API hay là dùng các 
        dịch vụ bên ngoài của webservice của google, facebook...
        useEffect Similar to componentDidMount and componentDidUpdate
        Một useEffect có return về 1 function, thì function này giống như componentWillUnmount()
            -> Component sẽ bị remove khỏi cấu trúc DOM 
    Use Effect deps: Có thể chỉ định lắng nghe sự thay đổi của state nào
        useEffect(() => {
            console.log("Lang nghe su thay doi cua counter");
        }, [counter]);
        Lắng nghe counter thay đổi 
Tìm hiểu về useMemo
    Returns a memoized value.
    Là 1 kỹ thuật dùng để cached dữ liệu lại 
    Dùng để chuyển đổi dữ liệu
    Không được lạm dụng, chỉ dùng khi biểu thức tính toán phức tạp 
    Cách dùng khác là dùng để tạo contructor bằng cách truyền empty deps và ko return về gì cả -> chỉ chạy 1 
        lần trước khi render
        useMemo(() => {
            console.log("constructor");
        }, []);
Tìm hiểu về useCallback
    Returns a memoized callback.
    Không được lạm dụng, chỉ dùng khi biểu thức tính toán phức tạp
Tìm hiểu về useRef
    Thường dùng khi tham chiếu đến 1 DOM nào đó 
Tìm hiểu Custom Hooks và useConstructor
    Các cách để tạo ra 1 constructor:
        Tạo 1 biến toàn cục
        useRef
        useMemo
        Sử dụng 1 Hooks do mình tự tạo ra để kế thừa 1 đoạn logic nào đó sử dụng đi sử dụng lại trong nhiều Component khác nhau
Ứng dụng Hooks trong tình huống thực tế - Demo
Solution 01
    Lỗi document is not define
    Khi tương tác đến server side render, phía server chạy trong môi trường nodeJs nên nó ko có trình duyệt -> không có document hay window 
    -> Sử dụng react Hooks
Solution 02
    useRef chỉ lắng nghe phần tử thay đổi 
    Chỉ chạy sau khi render -> chỉ chạy ở phía trình duyệt, ko chạy phía server 
    useMemo: Vừa chạy phía server và vừa chạy phía client 
    useRef: Có thể dùng đối với biến toàn cục không thay đổi
    useState: Có thể dùng đối với biến toàn cục có sự thay đổi
Solution 03
    <></> Bao ngoài của return của 1 Component để tránh sinh ra tag không cần thiết 
    renderFooter?: () => JSX.Element Trả về 1 cấu trúc html 
    